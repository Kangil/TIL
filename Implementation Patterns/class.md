# 클래스
- 관련성 있는 데이터와 로직을 함께 사용하기 위한 용도 (응집도를 올리기 위한?)


# 단순한 상위클래스 이름
- 명확한 의미 전달이 중요하며 가급적 짧게 한 단어로
- 몇개의 단어보다 은유가 좋을 때도 존재 (ex. 드로잉 프로그램의 Figure)


# 한정적 하위클래스 이름
- 간결성보다는 표현성을 선택
- 보통은 상위 클래스 이름 + 수식어를 붙이나 예외도 존재


# 추상 인터페이스
- 구현보다는 인터페이스에 맞춰 코딩
- 구현을 별도로 분리


# 인터페이스
- 인터페이스 사용시 구현의 변경은 쉽지만 인터페이스 자체 변경은 어려움
- 구상 클래스 이름의 간결함을 위해 보통 I를 붙여서 이름을 지음 (ex. IFile)


# 추상 클래스
- 인터페이스는 수정에 취약
    - 기존 설계 향상이 필요하면 버전 인터페이스 사용
- 추상 클래스의 경우 새로운 연산 추가 가능
- 인터페이스와 추상 클래스를 동시 사용도 가능


# 버전 인터페이스
- 인터페이스 변경이 필요한 경우 해당 인터페이스를 상속받아 새로운 인터페이스 생성
- 새로운 동작은 instanceof 연산자로 확인하고 downcast 하여 사용
- 대체 인터페이스가 늘어남은 설계 변경이 필요함 시점을 나타냄

```Java
interface Command {
    void run();
}

interface ReversibleCommand extends Command {
    void undo();
}

Command recent = ...;
if (recent instanceof ReversibleCommand) {
    ReversibleCommand downcasted = (ReversibleCommand) recent;
    downcasted.undo();
}
```


# 값 객체
- 프로그래밍의 두 가지 스타일
    - 프로시저 인터페이스 (객체의 상태 조작)
        - 호출 순서가 중요할수 있으며 묵시적 인터페이스 변경에 취약
    - 수학적 표현법 (함수형 스타일)
        - 상태 변경이 아닌 새로운 값 생성 (값 객체)
        - 호출 순서에 영향받지 않음
- 값객체의 경우 생성자에서만 값을 설정, 새로운 객체를 반환하며 반환된 객체의 저장은 연산을 요청한 쪽에

```Java
bounds.translateBy(10, 20); // 변경가능한 Rectangle 객체
bounds = bounds.translateBy(10, 20); // 값 스타일 Rectangle 객체
```

# 특화
- 연산 간의 유사점과 차이점을 부각시키는 방향으로 코드를 짜면 유지보수에 용이

# 하위클래스
- 상속은 공통된 구현을 갖는 경우 사용하며 분류를 위해서는 사용X
- 상위클래스의 각 메소드는 잘게 쪼개서 개별로 오버라이드 가능하게 구현
    - 상위클래스 메소드가 큰 경우 복사하여 수정하면되나 이 경우 암묵적 의존관계
- 하위클래스, 조건문, 위임을 각 경우에 맞게 사용
    - 변화하는 로직을 표현하기위해서는 하위클래스보다 조건문, 위임 사용
