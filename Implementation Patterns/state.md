# 상태
- 상태는 인간의 사고 구조상 자연적
- 프로그래밍 상의 위험 요소
    - 상태가 없으면 병렬 프로그래밍에도 유리 (함수형 언어)
- 상태를 다루는데 적합한 전략이 객체 지향
- 효과적인 상태 관리
    - 함께 사용되고 생성 소멸 시점이 동일한 상태를 밀접하게 관리

# 접근
- 프로그래밍 언어의 두가지 방식
    - 저장된 값에 대한 접근 (accessing stored value)
    - 계산 (invoking computation)
- 문맥에 따른 적절한 사용과 구분이 필요

# 직접 접근
```java
x = 10;
```
- 표현이 명확
- 유연성이 떨어짐 (수정에 취약)
- 프로그래밍 시 사고수준보다 낮은 수준의 세부 구현 사용 (추상화 단계가 낮음)
    - 원활한 커뮤니케이션을 방해

# 간접 접근
```java
// 함수만으로 표현
openDoor();
// 객체로 표현
door.open();
```
- 명확성이 떨어져 코드 읽기 힘들 수 있음 (내부 구현을 알아야하므로 ex. 리스터사용)
- 유연하게 내부 구현 변경 가능
- 기본적으로 이 방식을 추천!

# 공용 상태
- 여러 연산에서 같은 데이터 요소를 사용하는 경우
    - 클래스에 필드를 선언하여 사용

    ```java
    class Point {
        int x;
        int y;
    }
    ```
    - 같은 클래스에서의 가변 상태보다 명확
- 각 객체의 공용 상태는 범위와 생명 기간이 같아야함
- 객체의 일부 메소드에서만 사용하거나 특정 메소드 수행되는 동안만 유효한 필드 생성이 필요한 경우
    - 인자를 사용
    - 도우미 객체를 사용

# 가변 상태
- 단순 값만 다른것이 아닌 새로운 데이터 요소를 필요로 하는 경우
    - 데이터 요소 이름을 키로 값을 데이터로 하는 맵으로 표현

    ```java
    class FlexibleObject {
        Map<String, Object> properties = new HashMap<String, Object>();
        Object getProperty(String key) {
            return properties.get(key);
        }
        void setProperty(String key, Object value) {
            properties.set(key, value);
        }
    }
    ```

- 공용 상태보다 유연하지만 코드 읽기 어려움
- 각 필드의 상태에 따라 다른 필드를 필요로 하는 경우에만 사용
    - 가능하면 공용 상태를 사용!
- 다형성을 사용하면 공용 상태를 이용하여서도 표현 가능

# 외재 상태
- 특수 목적 정보는 객체가 아니라 그 객체를 필요로 하는 부분에 저장
- 사용시 객체 복사와 디버깅 어려움

# 변수
- 가급적 단순한 이름 사용
- 대부분 지역 변수를 사용, 간간히 정적 변수와 전용 변수(private)을 사용하길 추천
    - 문맥만으로도 변수 범위를 구분 가능 (이름에 불필요)
    - 조합 메소드와 같은 패턴사용하여 코드를 잘게 나눈 경우에만 가능
- 변수의 생명 주기는 변수 범위에 최대한 가까워지도록!
- 하나의 값을 가지는 변수와 복수 개의 변수 구분이 중요하므로 단수형, 복수형 사용

# 지역 변수
- 사용되기 직전, 최소 범위 내에서 선언하며 다음의 역할 수행
    - 컬렉터 : 이후 사용을 위한 정보 수집 목적
        - result, results
    - 카운터 : 특정 객체의 수를 저장하는 특수 컬렉터
    - 설명 : 복잡한 표현을 해야하는 경우
        - 도우미 메소드로도 변경가능
    - 재사용 : 기존 값을 다시 사용하는 경우
    - 원소 : 현재 사용하는 컬랙션의 원소를 저장하기 위해
        - each
    ```java
    broadcast() {
        for (Source eachSender: getSender())
            for (Destination eachReceiver: getReceivers())
                ...;
    }
    ```

# 필드
- 범위와 생명범위는 필드를 가진 객체와 동일
- 객체 전반에 걸쳐 사용되므로 가장 앞이나 뒤에 몰아서 선언
    - 선언을 나중인 경우 : 행위가 가장 중요하다는 의미
- 필드 변수의 역할
    - 도우미 : 객체의 여러 메소드에서 사용하는 객체 저장
        - 여러 메소드에서 객체를 파라미터로 받는 경우 생성자에서 필드로 설정 후 도우미 필드로 활용
    - 플래그 : 생명기간동안 동작방식이 변함을 의미
        - 플래그따라서 결정내리는 코드가 중복시 전략 필드 사용
    - 전략 : 객체 연상을 하는 다른 방법이 있는 경우, 해당 작업 수행하는 객체를 저장
        - 객체 생명기간 동안 연산 방법이 바뀌지 않는다면 생성자에서 설정
        - 객체 생명기간 동안 연산 방법이 바뀐다면 수정하는 메소드 제공
    - 상태 : 전략 필드와 비슷하지만 스스로 다음 상태를 설정
        - 상태와 상태 전이가 분리되어 코드 가독성이 떨어지므로 간단한 경우만 사용
    - 부속 : 부속(component) 필드는 해당 객체가 소유하는 객체나 데이터 저장
