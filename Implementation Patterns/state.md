# 상태
- 상태는 인간의 사고 구조상 자연적
- 프로그래밍 상의 위험 요소
    - 상태가 없으면 병렬 프로그래밍에도 유리 (함수형 언어)
- 상태를 다루는데 적합한 전략이 객체 지향
- 효과적인 상태 관리
    - 함께 사용되고 생성 소멸 시점이 동일한 상태를 밀접하게 관리

# 접근
- 프로그래밍 언어의 두가지 방식
    - 저장된 값에 대한 접근 (accessing stored value)
    - 계산 (invoking computation)
- 문맥에 따른 적절한 사용과 구분이 필요

# 직접 접근
```java
x = 10;
```
- 표현이 명확
- 유연성이 떨어짐 (수정에 취약)
- 프로그래밍 시 사고수준보다 낮은 수준의 세부 구현 사용 (추상화 단계가 낮음)
    - 원활한 커뮤니케이션을 방해

# 간접 접근
```java
// 함수만으로 표현
openDoor();
// 객체로 표현
door.open();
```
- 명확성이 떨어져 코드 읽기 힘들 수 있음 (내부 구현을 알아야하므로 ex. 리스터사용)
- 유연하게 내부 구현 변경 가능
- 기본적으로 이 방식을 추천!

# 공용 상태
- 여러 연산에서 같은 데이터 요소를 사용하는 경우
    - 클래스에 필드를 선언하여 사용

    ```java
    class Point {
        int x;
        int y;
    }
    ```
    - 같은 클래스에서의 가변 상태보다 명확
- 각 객체의 공용 상태는 범위와 생명 기간이 같아야함
- 객체의 일부 메소드에서만 사용하거나 특정 메소드 수행되는 동안만 유효한 필드 생성이 필요한 경우
    - 인자를 사용
    - 도우미 객체를 사용

# 가변 상태
- 단순 값만 다른것이 아닌 새로운 데이터 요소를 필요로 하는 경우
    - 데이터 요소 이름을 키로 값을 데이터로 하는 맵으로 표현

    ```java
    class FlexibleObject {
        Map<String, Object> properties = new HashMap<String, Object>();
        Object getProperty(String key) {
            return properties.get(key);
        }
        void setProperty(String key, Object value) {
            properties.set(key, value);
        }
    }
    ```

- 공용 상태보다 유연하지만 코드 읽기 어려움
- 각 필드의 상태에 따라 다른 필드를 필요로 하는 경우에만 사용
    - 가능하면 공용 상태를 사용!
- 다형성을 사용하면 공용 상태를 이용하여서도 표현 가능

# 외재 상태
- 특수 목적 정보는 객체가 아니라 그 객체를 필요로 하는 부분에 저장
- 사용시 객체 복사와 디버깅 어려움

# 변수
- 가급적 단순한 이름 사용
- 대부분 지역 변수를 사용, 간간히 정적 변수와 전용 변수(private)을 사용하길 추천
    - 문맥만으로도 변수 범위를 구분 가능 (이름에 불필요)
    - 조합 메소드와 같은 패턴사용하여 코드를 잘게 나눈 경우에만 가능
- 변수의 생명 주기는 변수 범위에 최대한 가까워지도록!
- 하나의 값을 가지는 변수와 복수 개의 변수 구분이 중요하므로 단수형, 복수형 사용

# 지역 변수
- 사용되기 직전, 최소 범위 내에서 선언하며 다음의 역할 수행
    - 컬렉터 : 이후 사용을 위한 정보 수집 목적
        - result, results
    - 카운터 : 특정 객체의 수를 저장하는 특수 컬렉터
    - 설명 : 복잡한 표현을 해야하는 경우
        - 도우미 메소드로도 변경가능
    - 재사용 : 기존 값을 다시 사용하는 경우
    - 원소 : 현재 사용하는 컬랙션의 원소를 저장하기 위해
        - each
    ```java
    broadcast() {
        for (Source eachSender: getSender())
            for (Destination eachReceiver: getReceivers())
                ...;
    }
    ```

# 필드
- 범위와 생명범위는 필드를 가진 객체와 동일
- 객체 전반에 걸쳐 사용되므로 가장 앞이나 뒤에 몰아서 선언
    - 선언을 나중인 경우 : 행위가 가장 중요하다는 의미
- 필드 변수의 역할
    - 도우미 : 객체의 여러 메소드에서 사용하는 객체 저장
        - 여러 메소드에서 객체를 파라미터로 받는 경우 생성자에서 필드로 설정 후 도우미 필드로 활용
    - 플래그 : 생명기간동안 동작방식이 변함을 의미
        - 플래그따라서 결정내리는 코드가 중복시 전략 필드 사용
    - 전략 : 객체 연상을 하는 다른 방법이 있는 경우, 해당 작업 수행하는 객체를 저장
        - 객체 생명기간 동안 연산 방법이 바뀌지 않는다면 생성자에서 설정
        - 객체 생명기간 동안 연산 방법이 바뀐다면 수정하는 메소드 제공
    - 상태 : 전략 필드와 비슷하지만 스스로 다음 상태를 설정
        - 상태와 상태 전이가 분리되어 코드 가독성이 떨어지므로 간단한 경우만 사용
    - 부속 : 부속(component) 필드는 해당 객체가 소유하는 객체나 데이터 저장

# 파라미터
- 비전용 변수(필드 혹은 전역 필드)를 사용하지 않고 상태를 다른 객체로 전달하기 위해 사용
    - 비전용 변수는 강한 의존성을 초래
    - 정적 변수와 파라미터 모두 가능하다면 언제나 파라미터사용!
- 하나의 객체에서 여러 메세지가 같은 파라미터를 사용한다면
    - 그 파라미터를 호출되는 객체에 포함시키는 편이 유리

# 수집 파라미터
- 여러 파라미터 호출 결과를 모으려면 통합 과정이 필요
    - 메소드 결과값을 반환 (정수처럼 단순한 경우)
    - 복잡한 방식이라면 파라미터로 전달하여 결과를 수집

    ```java
    asList() {
        List results = new ArrayList();
        addTo(results);
        return results;
    }
    addTo(List elements) {
        elements.add(getValue());
        for (Node each: getChildren())
            each.addTo(elements);
    }
    ```
# 옵션 파라미터
- 필수 파라미터는 앞에, 기본 값이 있는 옵션 파라미터는 뒤에

# 가변 인자
- 특정 파라미터를 여러 개 요구하는 경우
    - 컬렉션을 사용할 수 있으나 호출코드가 깔끔하지 않음
    - 가변인자를 사용
- 가변인자는 항상 마지막 파라미터로 지정

# 파라미터 객체
- 여러 개의 파라미터가 여러 개의 메소드에 전달되면
    - 하나의 객체로 처리
    - 일부 필드만 사용한다면 그에 해당하는 메소드를 파라미터 객체에 생성

```java
setOuterBounds(x, y, width, height);
setInnerBounds(x + 2, x + 2, width - 4, height - 4);
// 파라미터객체로 변경
setOuterBounds(bounds);
setInnerBounds(bounds.expand(-2));
```
- 파라미터 객체가 읽기 쉽고 테스트하기에도 쉬움
- 객체 생성이 성능에 문제가 되는 경우에만 사용하지 말것

# 상수
- 변하지 않는 데이터를 여러 부분에서 사용하고 컴파일시점에 값을 알고있다면
    - static final로 선언
    - 다른 변수와 구별하기 위해 대문자
- 흔히 인터페이스에서 메세지 종류를 나타내기 위해 사용
    - 각각 별도의 메소드를 사용하는 편이 좀더 의미가 명확
    ```java
    setJustification(Justification.CENTERED); // 상수 버전
    justifyCentered(); // 메소드 버전
    ```

# 역할 제시형 작명
- 코드는 읽히는 경우가 더 많으므로 변수명은 타이핑 쉬운 쪽보다 읽기 쉬운 쪽을 선택
    - 같은 맥락에서 단어의 축약도 비추천
- 변수 타입을 이름에 넣는건 비추천
    - 변수의 타입을 알고 싶다면 IDE 사용
    - 자바에는 타입 에러를 막아주는 수많은 장치 존재
- 짧은 조합 메소드(composed method)사용하면 편리
    - 짧은 메소드를 사용하면 변수의 볌위 판별도 간단
- 변수 이름은 가급적 짧고 명료하게
    - result : 반환되는 결과 저장
    - each : 컬렉션 순차 접근 시 각 원소 저장
    - count : 횟수 저장
- 변수명이 너무 길어질 경우 문맥을 살펴 짧은 이름을 사용
    - 변수명은 생명기간, 범위, 타입등은 문맥으로 전달
    - 변수명은 변수의 역할을 전달!
